# 17장 정렬

정렬 알고리즘은 목록의 요소를 특성 순서대로 넣는 알고리즘이다. 대개 숫자식 순서(Numberical Order)와 사전식 순서(Lexicographical Order)로 정렬한다.

## 버블 정렬

이 알고리즘은 n번의 라운드로 이뤄져 있으며, 각 라운드마다 배열의 아이템을 한 번씩 쭉 모두 살펴본다. 연달아 있는 아이템 2개의 순서가 잘못되어 있는 것을 발견하면, 두 아이템을 맞 바꾼다. 배열 전체를 쭉 살펴보는 것을 n번 하기 때문에 시간 복잡도는 항상 O(n^2)이다. 이보다 더 비효율적인 수는 없으며 구현 가능한 가장 느린 정렬 알고리즘이다.

```Python
def bubble_sort(A: List[int]) -> List[int]:
  for i in range(1, len(A)):
    for j in range(0, len(A) - 1):
      if A[j] > A[j + 1]:
        A[j], A[j + 1] = A[j + 1], A[j]
  return A
```

## 병합 정렬

병합 정렬(Merge Sort)은 존 폰 노이만(John von Neumann)이 1945년에 고안한 알고리즘으로, 분할 정복(Divide and Conquer)의 진수를 보여주는 알고리즘이다. 최선과 최악 모두 O(n log n)인 사실상 완전한 Theta(n log n)으로 일정한 알고리즘이며, 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도뿐만 아니라 무엇보다도 안정 정렬(Stable Sort)이라는 점에서 여전히 상용 라이브러리에 많이 쓰이고 있다. 각각 더 이상 쪼갤 수 없을 때까지 계속해서 분할한 후, 분할이 끝나면 정려라면서 정복해 나간다.

```Python
def merge_sort(A: List[int]) -> List[int]:
  if (len(A)) < 2:
    return A

  mid = len(A) // 2
  low_A = merge_sort(A[:mid])
  high_A = merge_sort(A[mid:)
  merged_A = []
  l = h = 0
  while l < len(low_A) and h < len(high_A):
    if low_A[l] < high_A[h]:
      merged_A.append(low_A[l])
      l += 1
    else:
      merged_A.append(high_A[h])
      h += 1
  merged_A += low_A[l:]
  merged_A += high[h:]
  return merged_A  
```

## 퀵 정렬

퀵 정렬(Quick Sort)은 토니 호어(Tony Hoare)가 1959년에 고안한 알고리즘으로, 피벗을 기준으로 좌우를 나누는 특징 때문에 파티션 교환 정렬(Partition-Exchange Sort)이라고도 불리운다. 병합 정렬과 마찬가지로 분할 정복 알고리즘이며 여기에 피벗(Pivot)이라는 개념을 통해 피벗보다 작으면 왼쪽, 크면 오른쪽과 같은 방식으로 파티셔닝하면서 쪼개 나간다. 여러 가지 변형과 개선 버전이 있는데 여기서는 N. 로무토(Lomuto)가 구현한 파티션 계획(Partition Scheme)을 살펴본다.

로무토 파티션이란 항상 맨 오른쪽의 피벗을 택하는 단순한 방식으로, 토니 호어가 고안한 최초의 퀵 정렬 알고리즘보다도 훨씬 더 간결하고 이해하기 쉽기 때문에 퀵 정렬을 소개할 때는 항상 맨 처음에 언급되며, Introduction to Algorithms에서도 '퀵 정렬' 맨 처음에 등장하는 가장 기본적인 방식이기도 하다. 로무토 파티션은 맨 오르쪽을 피벗으로 정하는 가장 단순한 방식이다. 피벗은 맨 오른쪽 값을 기준으로 하며, 이를 기준으로 2개의 포인터가 이동해서 오른쪽 포인터의 값이 피벗보다 작다면 서로 스왑하는 형태로 진행된다. 오른쪽 포인터가 이동하면서 피벗의 값이 오른쪽 값보다 더 클 때, 왼쪽과 오른쪽의 스왑이 진행된다. 스왑 이후에는 왼쪽 포인터가 함께 이동한다. 오른쪽 포인터가 끝에 도달하게 되면 왼쪽 포인터의 위치로 피벗 아이템이 이동한다. 결과를 보면 피봇을 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽으로 분할되어 있고, 피벗이 그 중앙으로 이동하는 모습을 확인할 수 있다. 이렇게 계속 분할하면서 정복을 진행하여 코드 기준으로 lo < hi를 만족하지 않을 때까지, 즉 서로 위치가 역전할 때까지 계속 재귀로 반복하면서 정렬이 완료된다.

퀵 정렬은 그 이름처럼 매우 빠르며 굉장히 효율적인 알고리즘이다. 그러나 최악의 경우에는 O(N^2)이 된다. 만약 이미 정렬된 배열이 입력값으로 들어왔다고 가정해보자. 이 경우 피벗은 계속 오른쪽에 위치하게 되므로 파티셔닝이 전혀 이뤄지지 않는다. 이 때 n번의 라운드에 걸쳐 결국 전체를 비교하기 때문에, 버블 정렬과 다를 바 없는 최악의 성능을 보이게 된다. 항상 일정한 성능을 보이는 병합 정렬과 달리, 퀵 정렬은 이처럼 입력값에 따라 성능 편차가 심한 편이다. 하지만 피벗을 선택하는 알고리즘을 개선해 퀵 정렬을 좀 더 최적화하는 등 이미 다양한 연구 결과가 많이 나와 있기도 하다.

```Python
def quick_sort(A: List[int], lo: int, ho: int) -> List[int]:
  def partition(lo: int, hi: int) -> None:
    pivot = A[hi]
    left = lo
    for right in range(lo, hi):
      if A[right] < pivot:
        A[left], A[right] = A[right], A[left]
        left += 1
    A[left], A[hi] = A[hi], A[left]
    return left

  if lo < hi:
    pivot = partition(lo, hi)
    quicksort(A, lo, pivot - 1)
    quicksort(A, pivot + 1, hi)
```

## 안정 정렬 vs 불안정 정렬

안정 정렬(Stable Sort) 알고리즘은 중복된 값을 입력 순서와 동일하게 정렬한다.

안정 정렬의 경우에는 기존의 시간 순으로 정렬했던 순서는 지역명으로 재정렬하더라도 기존 순서가 그대로 유지된 상태에서 정렬이 이뤄진다. 그러나 불안정 정렬의 경우에는 시간 순으로 정렬한 값을 지역명으로 재정려라면 기존의 정렬 순서는 무시된 채 모두 뒤죽박죽 뒤섞이고 만다. 이처럼 입력값이 유지되는 안정 정렬 알고리즘이 유지되지 않는 불안정 정렬 알고리즘보다 훨씬 더 유용하다.

대표적으로 병합 정렬은 안정 정렬이며, 심지어 버블 정렬 또한 안정 정렬이다. 반면 퀵 정렬은 불안정 정렬이다. 게다가 입력값에 따라 버블 정렬 만큼이나 느려질 수 있다. 이처럼 고르지 않는 성능 탓에 실무에서는 병합 정렬이 여전히 활발히 쓰이고 있으며, 파이썬의 기본 정렬 알고리즘으로는 벼압 정렬과 삽입 정렬을 휴리스틱하게 조합한 팀소트(Timsort)를 사용한다.

:bulb: 콤마(,) 연산자

행렬의 연결(Concatenate) 연산과 동일하다. 

```Python
>>> a = [1]
>>> b = [2, 3]
>>> a += b
>>> a
[1, 2, 3
```

```Python
>>> a = [1]
>>> b = [2, 3]
>>> a += b,
>>> a
[1, [2, 3]]

이렇게 중첩 리스트가 된다. 콤마는 중첩 리스트로 만들어주는 역할을 하며, 대괄호 []를 부여한 것과 동일한 역할을 한다.
```
