# 3장 파이썬
실행 가능한 수도코드(Executable Pseudocode)라는 별칭으로도 불린다.

## 파이썬에 대한 이해

## 파이썬 문법

### 인덴트
첫 번째 줄에 파라미터가 있다면, 파라미터가 시작되는 부분에 보기 좋게 맞춘다.

첫 번째 줄에 파라미터가 없다면, 공백 4칸 인덴트를 한 번 더 추가하여 다른 행과 구분되게 한다.

여러 줄로 나눠쓸 경우 다음 행과 구분되도록 인덴트를 추가한다.

파이참에서 Reformat Code를 실행하면 자동으로 코드를 PEP 8 기준에 맞춰주기 때문에 매우 편리하다.

### 네이밍 컨벤션
파이썬의 변수명 네이밍 컨벤션(Naming Convetion)은 자바와 달리 각 단어를 밑줄(`_`)로 구분하여 표기하는 스네이크 케이스(Snake Case)를 따른다. 이는 함수명도 마찬가지다. 특히 파이썬은 pythonic way에 굉장한 자부심이 있어서, 카멜 케이스뿐만 아니라 자바 스타일로 코딩하는 것을 지양한다(파이썬과 달리 자바에서는 단어별로 대소문자를 구별하여 표기하는 카멜 케이스(Camel Case)를 따른다).

:bulb: 카멜 케이스, 스네이크 케이스

카멜 케이스는 낙타처럼 생긴 것에 유래해 부른 이름이며 단어를 대소문자로 구분하여 섞어서 작명하는 방식으로, 자바의 대표적인 표기 방식이기도 하다. 특이하게도 단어의 첫 문자는 모두 대문자로 시작하지만, 첫 단어의 시작 문자는 소문자로 표기하며, 첫 시작 문자도 대문자로 하는 방식은 파스칼 케이스(Pascal Case)라 한다.

스네이크 케이스는 뱀과 같은 모양에서 유래했으며 각 단어를 언더스코어(`_`)로 구분한다. 일반적으로 모두 소문자로 표기하지만 경우에 따라 시작 문자는 대문자로 표기하기도 한다. 연구 결과에 따르면 스네이크 케이스가 카멜 케이스보다 훨씬 더 인지하기 쉽다고 한다. 파이썬은 PEP 8을 통해 스네이크 케이스 방식의 네이밍 컨벤션을 권장한다.

### 타입 힌트

강제 규약이 아니다 보니, 여전히 동적으로 할당될 수 있으므로 주의가 필요하다. `mypy`를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인할 수 있다. 타입 힌트가 잘못 지정된 코드는 Incompatible return value type 오류가 발생하므로 확인 후 직접 코드를 수정할 수 있다.

### 리스트 컴프리헨션

파이썬은 map, filter와 같은 함수형(Functional) 기능을 지원하며 다음과 같은 람다 표현식(Lambda Expression)도 지원한다.

```Python
>>> list(map(lambda x: x + 10, [1, 2, 3]))
[11, 12, 13]
```

자바는 2014년에 출시된 8 버전에 이르러서야 람다 표현식을 지원하기 시작한 데 반해, 파이썬은 이미 1.0 버전, 즉 1994년부터 람다를 지원했을 만큼 역사가 오래 됐다. 그러나 사실 파이썬의 훨씬 더 유용한 기능은 리스트 컴프리헨션(List Comprehension)이다. 리스트 컴프리헨션이란 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문으로, 파이썬 2.0부터 지원되었으며, 하스켈(Haskell) 같은 함수형 언어에서 기능을 차용해온 파이썬의 대표적인 특징이기도 하다. Effective Python 파이썬 코딩의 기술에서도 1장 파이썬다운 생각 중 Better way 7: map과 filter 대신 리스트 컴프리헨션을 사용하자는 절이 있을 정도로 리스트 컴프리헨션은 다방면에 유용하게 활용되며, 무엇보다 람다 표현식에 map이나 filter를 섞어서 사용하는 것에 비해 가독성이 훨씬 높다. 버전 2.7 이후에는 리스트 외에도 딕셔너리 등이 가능하도록 추가됐다. `a = {key: value for key, value in original.items()}` 대체로 표현식은 2개를 넘지 않아야 한다.

### 제너레이터
루프의 반복(Iteration) 동작을 제어할 수 있는 루틴 형태를 말한다. yield 구문을 사용하면 제너레이터를 리턴할 수 있다. 기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료한다. 그러나 yield는 제너레이터가 여기까지 실행 중이던 값을 내보낸다는(단어의 사전적 의미처럼 양보하다) 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계쏙해서 맨 끝에 도달할 때까지 실행된다. 다음 값을 생성하려면 next()로 추출하면 된다. 아울러 제너레이터는 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능하다.

### range
제너레이터의 방식을 활용하는 대표적인 함수로 range()가 있다. 주로 for 문에서 쓰인다.

range()는 range 클래스를 리턴하며, for 문에서 사용할 경우 내부적으로는 제너레이터의 next()를 호출하듯 매번 다음 숫자를 생성해내게 된다. 참고로 파이썬 2.x 버전까지는 range() 함수가 지금과 같은 형태가 아니었다. 숫자를 미리 생성해서 리스트로 리턴하는 방식이었고(파이썬 3.x의 list(range(x)) 결과와 동일하다) 제너레이터를 리턴하는 방식은 xrange()라고 따로 존재했다. 그러다가 버전 3 이후, range() 함수가 제너레이터 역할을 하는 range 클래스를 리턴하는 형태로 변경됐고 xrange() 함수는 사라졌다.

생성 조건만 보관하고 있다. 게다가 미리 생성하지 않은 값은 인덱스에 접근이 안될 거라 생각할 수 있으나, 인덱스로 접근 시에는 바로 생성하도록 구현되어 있기 때문에 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있다. 

### enumerate
enumerate()는 열거하다는 뜻의 함수로, 순서가 있는 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate 객체로 리턴한다. 인덱스를 자동으로 부여해주기 때문에 매우 편리하게 활용할 수 있다.

### // 나눗셈 연산자
// 연산자가 바로 과거 파이썬 2 이하 버전의 나눗셈 연산자 /와 동일한 역할을 한다. 정수형을 나눗셈할 때 동일한 정수형을 경과로 리턴하면서 내림(Floor Division) 연산자의 역할을 한다. 다시 말해 몫(Quitient)을 구하는 연산자다. 

나머지(Remainder)를 구하는 모듈로(Modulo) 연산자는 %이다.

몫과 나머지를 동시에 구하려면 divmod() 함수를 사용하면 된다.

### print
파이썬 2.x까지는 print 절(Statement)이었으나, 3.x로 오면서 print() 함수로 바뀌었다.

리스트를 출력할 때는 join()으로 묶어서 처리한다. 인덱스와 함께 사용 가능하다. 또한 인덱스를 생략할 수 있다. f-string(formated string literal) 방법은 변수를 뒤에 별도로 부여할 필요 없이 마치 템플릿을 사용하듯 인라인으로 삽일할 수 있어 편리하게 사용할 수 있다. 무엇보다 기존의 %를 사용하거나, .format을 부여하는 방식에 비해 훨씬 간결하고 직관적이며 속도도 빠르다. f-string은 파이썬 3.6+에서만 지원한다. 그 이하 버전에서는 동작하지 않는다.

### pass
파이썬에서 pass는 널 연산(Null Operation)으로 아무것도 하지 않는 기능이다. pass는 먼저 목업(mockup) 인터페이스부터 구현한 다음에 추후 구현을 진행할 수 있게 한다.

### locals
locals()는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드로 업데이트 또한 가능하다. 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명령이므로 디버깅에 많은 도움이 된다. 특히 로컬 스코프에 제한해 정보를 조회할 수 있기 때문에 클래스의 특정 메소드 내부에서나 함수 내부의 로컬 정보를 조회해 잘못 선언한 부분이 없는지 확인하는 용도로 활용할 수 있다. 변수명을 일일이 찾아낼 필요 없이 로컬 스코프에 정의된 모든 변수를 출력하기 때문에 편리하다. pprint로 출력하게 되면 보기 좋게 줄바꿈 처리를 해주기 때문에 가독성이 높다. 클래스 메소드 내부의 모든 로컬 변수를 출력해주기 때문에 디버깅에 많은 도움이 된다.

## 코딩 스타일
Clean Code 클린 코드, 프로그래밍 수련법, PEP 8, 구글의 파이썬 스타일 가이드

### 변수명과 주석
항상 코드에 상세한 주석을 달아두는 편이 좋다.

### 리스트 컴프리헨션

### 구글 파이썬 스타일 가이드
함수의 기본 값으로 가변 객체(Mutable Object)를 사용하지 않아야 한다. 대신 불변 객체(Immutable Object)를 사용한다. None을 명시적으로 할당하는 것도 좋은 방법이다. True, False를 판별할 때는 암시적(Implicit)인 방법을 사용하는 편이 간결하고 가독성이 높다.

세미콜론으로 줄을 끝내서는 안 되며, 세미콜론을 사용해 같은 줄에 두 문장을 써서도 안 된다.

최대 줄 길이는 80자로 한다. 

:bulb: 파이썬 철학, 파이썬다운 방식, Pythonic Way, Zen of Python, `import this`
