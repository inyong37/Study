# 5장 리스트, 딕셔너리

## 리스트
파이썬의 리스트(List)는 말 그대로 순서대로 저장하는 시퀀스이자 변경 가능한 목록(Mutable List)을 말한다. 입력 순서가 유지되며, 내부적으로는 동적 배열로 구현되어 있다.

- C++: std::vector
- Java: ArrayList
- Python: list()

|연산|시간 복잡도|설명|
|:-:|:----------|:--|
|len(a)|O(1)|전체 요소의 개수를 리턴한다.|
|a[i]|O(1)|인덱스 i의 요소를 가져온다.|
|a[i:j]|O(k)|i부터 j까지의 슬라이스의 길이만큼인 k개의 요소를 가져온다. 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.|
|ele in a|O(n)|ele 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다.|
|a.count(ele)|O(n)|ele 요소의 개수를 리턴한다.|
|a.index(ele)|O(n)|ele 요소의 인덱스를 리턴한다.|
|a.append(ele)|O(1)|리스트 마지막에 ele 요소를 추가한다.|
|a.pop()|O(1)|리스트 마지막 요소를 추출한다. 스택의 연산이다.|
|a.pop(0)|O(n)|리스트 첫번째 요소를 추출한다. 큐의 연산이다. 이 경우 전체 복사가 필요하므로 O(n)이다. 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 데크(deque)를 권장한다.|
|del a[i]|O(n)|i에 따라 다르다. 최악의 경우 O(n)이다.|
|a.sort()|O(n log n)|정렬한다. 팀소트(Timsort)를 사용하며, 최선의 경우 O(n)에도 실행될 수 있다.|
|min(a), max(a)|O(n)|최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.|
|a.reverse()|O(n)|뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.|

### 리스트의 활용 방법
- insert() 함수를 사용하면 특정 위치의 인덱스를 지정해 요소를 추가할 수 있다.

파이썬의 리스트는 숫자 외에도 다양한 자료형을 단일 리스트에 관리할 수 있어 매우 편리하다. 

파이썬 리스트에는 슬라이싱(Slicing) 기능이 있어 특정 범위 내의 값을 매우 편리하게 가져올 수 있다. 원래 슬라이싱은 문자열에 유용하게 활용되는 기능으로서, 리스트에도 동일한 형태로 매우 유용하게 활용할 수 있다. 슬라이싱은 간결함과 강력함을 자랑하는 파이썬의 특징을 잘 나타내는 대표적인 기능 중 하나로, 유난히 돋보이는 장점이기도 하다. 다른 언어들은 인덱스의 반복문을 구성하고 순회하면서 값을 출력해야 하는데, 파이썬의 슬라이싱은 이처럼 시작 인덱스와 종료 인덱스를 설정해 간단히 해당하는 값을 출력할 수 있다. 시작 인덱스는 생략할 수 있다. 또는 종료 인덱스를 생략할 수 있다. 세 번째 파라미터를 부여하면 단계(Step)의 의미이다.

- del 키워드를 사용하면 인덱스의 위치에 있는 요소를 삭제할 수 있다.

- remove() 함수를 사용하면 값에 해당하는 요소를 삭제할 수 있다.

- pop() 함수를 사용하면 스택의 팝(pop) 연산처럼 추출로 처리된다. 즉 삭제될 값을 리턴하고 삭제가 진행된다. 

### 리스트의 특징
파이썬의 리스트는 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 듯한 형태를 띠며, 실제로 리스트를 잘 사용하기만 해도 배열과 연결 리스트가 모두 필요 없을 정도로 강력하다.

CPython에서 리스트는 요소에 대한 포인터 목록(ob_item)을 갖고 있는 구조체(Struct)로 선언되어 있다. 리스트에 요소를 추가하거나 조작하기 시작하면 ob_item의 사이즈를 조절해 나가는 형태로 구현되어 있다.

리스트는 객체로 되어 있는 모든 자료형을 포인터로 연결한다.

파이썬은 모든 것이 객체며, 파이썬의 리스트는 이들 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다. 사실상 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하고 있으며, 그 덕분에 파이썬의 리스트는 배열과 연결 리스트를 합친 듯이 강력한 기능을 자랑한다.

정수, 문자, 불리언 모두 제각각인 자료형을 단일 리스트에 모두 통합해서 저장할 수 있다. 이러한 특징은 매우 강력하며 매우 편리하게 활용할 수 있다. 그러나 각 자료형의 크기는 저마다 서로 다르기 때문에 이들을 연속된 메모리 공간에 할당하는 것은 불가능하다. 결국 각각의 개체에 대한 참조로 구현할 수밖에 없다. 당연히 인덱스를 조회하는 데에도 모든 포인터의 위치를 찾아가서 타입 코드를 확인하고 값을 일일이 살펴봐야 하는 등 추가적인 작업이 필요하기 때문에, 속도 면에서도 훨씬 더 불리하다. 이처럼 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 참조를 택했으며, 이로 인해 부득이하게 속도를 희생한 측면이 있다.

## 딕셔너리
파이썬의 딕셔너리는 키/값 구조로 이뤄진 딕셔너리를 말한다. 파이썬 3.7+에서는 입력 순서가 유지되며, 내부적으로는 해시 테이블(Hash Table)로 구현되어 있다.

- C++: std::unordered_map
- Java: HashMap
- Python: dict()

인덱스를 숫자로만 지정할 수 있는 리스트와 달리 딕셔너리는 문자를 포함해 다양한 타입을 키로 사용할 수 있다. 특히 파이썬의 딕셔너리는 해시할 수만 있다면 숫자뿐만 아니라, 문자, 집합까지 불변 객체를 모두 키로 사용할 수 있다. 이 과정을 해싱이라고 하며, 해시 테이블을 이용해 자료를 저장한다. 무엇보다 해시 테이블은 다양한 타입을 키로 지원하면서도 입력과 조회 모두 O(1)에 가능하다. 물론 해시 테이블은 최작의 경우 O(n)이 될 수 있으나 대부분의 경우 훨씬 더 빨리 실행되며, 분할 상환 분석(Amortized Analysus)에 따른 시간 복잡도는 O(1)이다.

|연산|시간 복잡도|설명|
|:-:|:----------|:--|
|len(a)|O(1)|요소의 개수를 리턴한다.|
|a[key]|O(1)|키를 조회하여 값을 리턴한다.|
|a[key] = value|O(1)|키/값을 삽입한다.|
|key in a|O(1)|딕셔너리에 키가 존재하는지 확인한다.|

이처럼 딕셔너리는 대부분의 연산이 O(1)에 처리 가능한 매우 우수한 자료형이다. 원래 파이썬에서 딕셔너리는 입력 순서가 유지되지 않았다. 마찬가지로 대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다. 파이썬도 3.6 이하에서는 입력 순서가 유지되지 않아 collections.OrderedDict()라는 별도 자료형을 제공했다. 그러나 파이썬 3.7부터는 내부적으로 인덱스를 이용해 입력 순서를 유지하도록 개선됐다. 이외에도 파이썬 3.6부터는 딕셔너리의 메모리 사용량이 20% 정도 줄어드는 성능 개선 또한 진행됐다.

조회 시 항상 디폴트 값을 생성해 키 오류를 방지하는 collections.defaultDict(), 요소의 값을 키로 하고 개수를 값 형태로 만들어 카운팅하는 collections.Counter() 등이 있다.

### 딕셔너리의 활용 방법
딕셔너리의 있는 키/값은 for 반복문으로도 조회가 가능하다. items() 메소드를 사용하면 키와 값을 각각 꺼내올 수 있다. `for key, val in a.items(): print(key, val)`

딕셔너리의 키는 del로 삭제한다. `del a['key1`]

### 딕셔너리 모듈
딕셔너리와 관련된 특수한 형태의 컨테이너 자료형인 defaultdict, Counter, OrderedDict이 있다.

#### defaultdict 객체
defaultdict 객체는 존재하지 않는 키를 조회할 경우, 에러 메시지를 출력하는 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다. 마찬가지로 실제로는 collections.defaultdict 클래스를 갖는다.

디폴트인 0을 기준으로 자동으로 생성한다.

#### Counter 객체
Counter 객체는 아이템에 대한 개수를 계산해 딕셔너리로 리턴한다. Counter 객체는 키에는 아이템의 값이, 값에는 해당 아이템의 개수가 들어간 딕셔너리를 생성한다. 실제로는 딕셔너리를 한 번 더 래핑(Wraaping)한 collections.Counter 클래스를 갖는다. 개수를 자동으로 계산해주기 때문에 매우 편리하다. 

- most_common()을 사용해 가장 빈도 수가 높은 요소를 추출할 수 있다. most_common(2)를 사용하면 빈도 수가 가장 높은 2개의 요소를 추출할 수 있다.

#### OrderedDict 객체
대부분의 언어에서 해시 테이블을 이용한 자료형은 입력 순서가 유지되지 않는다. OrderedDict는 입력 그대로 순서가 유지된다.

OrderedDict는 순서와 관련된 몇 가지 추가 메소드를 제공한다는 점 이외에는 사실상 하위 호환성을 위해서만 남겨졌다. 그러나 하위 버전의 파이썬 인터프리터를 사용하는 경우, 원래 해시 테이블은 입력 순서에 관여하지 않는 자료형인 만큼, 무턱대고 딕셔너리로 입력 순서를 기대하는 것은 매우 위험하며 권장하지 않는 방법이다.

:bulb: 타입 선언

파이썬에서 타입을 선언하는 문법은 타입의 이름을 지정하는 방법이 있지만, 기호를 사용해서 좀 더 간편하게 처리할 수도 있다. 먼저 이름으로 사용하는 방식은 다음과 같다.

```Python
>>> a = list()
```

이처럼 이름으로 리스트를 선언하고 타입을 확인하면 list 자료형이 된다. 각각의 기호와 자료형은 다음과 같다.

```Python
>>> type([])
>>> type(())
>>> type({}) // dict
>>> type({1}) // set
```

각각 리스트, 튜플, 딕셔너리, 집합을 기호로 선언한 경우다. 이 중에서 딕셔너리와 집합은 같은 중괄호 {}를 사용하지만 키의 존재 유무로 서로 다른 자료형으로 선언된다. 이처럼 키 없이 값만 1로 선언할 경우 결과는 집합 자료형이 된다.
