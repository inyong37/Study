# 5장 리스트, 딕셔너리

## 리스트
파이썬의 리스트(List)는 말 그대로 순서대로 저장하는 시퀀스이자 변경 가능한 목록(Mutable List)을 말한다. 입력 순서가 유지되며, 내부적으로는 동적 배열로 구현되어 있다.

- C++: std::vector
- Java: ArrayList
- Python: list()

|연산|시간 복잡도|설명|
|:-:|:----------|:--|
|len(a)|O(1)|전체 요소의 개수를 리턴한다.|
|a[i]|O(1)|인덱스 i의 요소를 가져온다.|
|a[i:j]|O(k)|i부터 j까지의 슬라이스의 길이만큼인 k개의 요소를 가져온다. 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.|
|ele in a|O(n)|ele 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다.|
|a.count(ele)|O(n)|ele 요소의 개수를 리턴한다.|
|a.index(ele)|O(n)|ele 요소의 인덱스를 리턴한다.|
|a.append(ele)|O(1)|리스트 마지막에 ele 요소를 추가한다.|
|a.pop()|O(1)|리스트 마지막 요소를 추출한다. 스택의 연산이다.|
|a.pop(0)|O(n)|리스트 첫번째 요소를 추출한다. 큐의 연산이다. 이 경우 전체 복사가 필요하므로 O(n)이다. 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 데크(deque)를 권장한다.|
|del a[i]|O(n)|i에 따라 다르다. 최악의 경우 O(n)이다.|
|a.sort()|O(n log n)|정렬한다. 팀소트(Timsort)를 사용하며, 최선의 경우 O(n)에도 실행될 수 있다.|
|min(a), max(a)|O(n)|최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다.|
|a.reverse()|O(n)|뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.|

### 리스트의 활용 방법
- insert() 함수를 사용하면 특정 위치의 인덱스를 지정해 요소를 추가할 수 있다.

파이썬의 리스트는 숫자 외에도 다양한 자료형을 단일 리스트에 관리할 수 있어 매우 편리하다. 

파이썬 리스트에는 슬라이싱(Slicing) 기능이 있어 특정 범위 내의 값을 매우 편리하게 가져올 수 있다. 원래 슬라이싱은 문자열에 유용하게 활용되는 기능으로서, 리스트에도 동일한 형태로 매우 유용하게 활용할 수 있다. 슬라이싱은 간결함과 강력함을 자랑하는 파이썬의 특징을 잘 나타내는 대표적인 기능 중 하나로, 유난히 돋보이는 장점이기도 하다. 다른 언어들은 인덱스의 반복문을 구성하고 순회하면서 값을 출력해야 하는데, 파이썬의 슬라이싱은 이처럼 시작 인덱스와 종료 인덱스를 설정해 간단히 해당하는 값을 출력할 수 있다. 시작 인덱스는 생략할 수 있다. 또는 종료 인덱스를 생략할 수 있다. 세 번째 파라미터를 부여하면 단계(Step)의 의미이다.

- del 키워드를 사용하면 인덱스의 위치에 있는 요소를 삭제할 수 있다.

- remove() 함수를 사용하면 값에 해당하는 요소를 삭제할 수 있다.

- pop() 함수를 사용하면 스택의 팝(pop) 연산처럼 추출로 처리된다. 즉 삭제될 값을 리턴하고 삭제가 진행된다. 

### 리스트의 특징
파이썬의 리스트는 연속된 공간에 요소를 배치하는 배열의 장점과 다양한 타입을 연결해 배치하는 연결 리스트의 장점을 모두 취한 듯한 형태를 띠며, 실제로 리스트를 잘 사용하기만 해도 배열과 연결 리스트가 모두 필요 없을 정도로 강력하다.

CPython에서 리스트는 요소에 대한 포인터 목록(ob_item)을 갖고 있는 구조체(Struct)로 선언되어 있다. 리스트에 요소를 추가하거나 조작하기 시작하면 ob_item의 사이즈를 조절해 나가는 형태로 구현되어 있다.

리스트는 객체로 되어 있는 모든 자료형을 포인터로 연결한다.

파이썬은 모든 것이 객체며, 파이썬의 리스트는 이들 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다. 사실상 연결 리스트에 대한 포인터 목록을 배열 형태로 관리하고 있으며, 그 덕분에 파이썬의 리스트는 배열과 연결 리스트를 합친 듯이 강력한 기능을 자랑한다.

정수, 문자, 불리언 모두 제각각인 자료형을 단일 리스트에 모두 통합해서 저장할 수 있다. 이러한 특징은 매우 강력하며 매우 편리하게 활용할 수 있다. 그러나 각 자료형의 크기는 저마다 서로 다르기 때문에 이들을 연속된 메모리 공간에 할당하는 것은 불가능하다. 결국 각각의 개체에 대한 참조로 구현할 수밖에 없다. 당연히 인덱스를 조회하는 데에도 모든 포인터의 위치를 찾아가서 타입 코드를 확인하고 값을 일일이 살펴봐야 하는 등 추가적인 작업이 필요하기 때문에, 속도 면에서도 훨씬 더 불리하다. 이처럼 파이썬은 강력한 기능을 위해 리스트와 객체에 대한 참조를 택했으며, 이로 인해 부득이하게 속도를 희생한 측면이 있다.
