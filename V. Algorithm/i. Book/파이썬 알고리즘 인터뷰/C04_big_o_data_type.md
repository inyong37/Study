# 4장 빅오, 자료형
컴퓨터과학에서 빅오는 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는 데 사용되며, 알고리즘의 효율성을 분석하는 데에도 매우 유용하게 활용된다.

## 빅오
빅오(O, big-O)란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법이다.

빅오는 점근적 실행 시간(Asymptotic Running Time)를 표기할 때 가장 널리 쓰이는 수학적 표기 중 하나다. 점근적 실행 시간이란 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 limit n-> inf 함수의 실행 시간의 추이를 의미한다. 알고리즘은 궁극적으로 컴퓨터로 구현되므로, 컴퓨터의 빠른 처리 능력을 감안하면 아무리 복잡한 알고리즘도 입력의 크기가 작으면 금방 끝나버린다. 그러므로 관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다. 충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.

점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있다. 시간 복잡도(Time Complexity)의 사전적 정의는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도(Computational Complexity)를 의미하며, 계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다.

- O(1): 입력값이 아무리 커도 실행 시간은 일정하다. 최고의 알고리즘이라 할 수 있다. O(1)에 실행되는 알고리즘으로 해시 테이블의 조회 및 삽입이 이에 해당한다.
- O(log n): 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편으로 웬만한 n의 크기에 대해서도 매우 견고하다. 대표적으로 이진 검색이 이에 해당한다.
- O(n): 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간(Linear-Time) 알고리즘이라고 한다. 정렬되지 않은 리스트에서 최댓값 또는 최솟값 경우가 이에 해당하며 이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴봐야 한다.
- O(n log n): 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다. 적어도 모든 수에 대해 한 번 이상은 비교해야 하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘도 O(n log n)보다 빠를 수 없다. 물론 입력값이 최선인 경우, 비교를 건너뛰어 O(n)이 될 수 있으며 팀소트(Timsort)가 이런 로직을 갖고 있다.
- O(n^2): 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당한다.
- O(2^n): 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다. n^2과 혼동하는 경우가 있는데 처음에는 비슷해 보이지만 2^n이 훨씬 더 크다.
- O(n!): 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제(Travelling Salesman Problem, TSP)를 브루트 포스로 풀이할 때가 이에 해당한다. 가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항 시간 내에는 계산이 어렵다.

빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰인다. 또한 알고리즘은 흔히 '시간과 공간이 트레이드오프(Space-Time Tradeoff)' 관계다. 이 말은 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다는 얘기다.

### 상한과 최악
빅오(O)는 상한(Upper Bound)을 의미한다. 이외에도 하한(Lower Bound)을 나타내는 빅오메가, 평균을 의미하는 빅세타가 있는데, 학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있다. 평균적인 시간보다는 상한 시간으로 단순화해서 주로 표현하는데, 매번 구분하는 것이 번거롭고 혼동되기도 하며 또한 상한으로만 표현하는 방법이 틀리지 않기 때문이기도 하다.

빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 '적당히 정확하게' 표현하는 방법일 뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이라는 점에 유의해야 한다.

빅오 표기는 복잡한 함수 f(n)이 있을 경우, 이 함수의 실행 상한과 하한을 의미한다. 즉 가장 빨리 실행될 때(하한), 가장 늦게 실행될 때(상한)를 뜻하며 이 중 가장 늦게 실행될 때를 빅오(O), 가장 빨리 실행될 때를 빅오메가, 평균적으로는 빅세타로 지칭한다.

빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.

### 분할 상환 분석
시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 분할 상환 분석 방법이 등장하는 계기가 됐다.

분할 상환 분석(Amortized Analysis)은 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나다. 분할 상환 분석이 유용한 대표적인 예로 '동적 배열'을 들 수 있는데, 동적 배열에서 더블링이 일어나는 일은 어쩌다 한 번뿐이지만, 이로 인해 '아이템 삽입 시간 복잡도는 O(n)이다.'라고 얘기하는 건 지나치게 비관적이고 정확하지도 않다. 따라서 이 경우 '분할 상환' 또는 '상각'이라고 표현하는, 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다. 이렇게 할 경우 동적 배열의 삽입 시 시간 복잡도는 O(1)이 된다. 이 방법은 1985년 미국의 수학자이자 컴퓨터과학자인 로버트 타잔(Robert Tarjan)이 "상각된 계산 복잡도(Amortized Computational Complexity)"라는 논문에서 처음으로 소개했으며, 그 유용함 덕북에 최근에는 시간 복잡도를 분석할 때 매우 보편적으로 널리 사용되는 방법이기도 하다.

### 병렬화
일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다. 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도 중 하나이다.

## 자료형
코딩 테스트에서도 가장 많이 사용할 2가지 자료형인 리스트(List)와 딕셔너리(Dictionary)에 대해 중점적으로 살펴본다.

### 파이썬 자료형
- 파이썬3 표준 타입 계층 구조
- None(class None Type)
- 숫자
  - 정수형
    - 정수(class int)
    - 불리언(class bool)
  - 실수(class float)
- 집합형
  - 집합(class set)
- 시퀀스
  - 불변
    - 문자열(class str)
    - 튜플(class tuple)
    - 바이트(class bytes)
  - 가변
    - 리스트(class list)
- 매핑
  - 딕셔너리(class dict)

#### 숫자
파이썬에서는 숫자 정수형으로 int만을 제공한다. int는 임의 정밀도를 지원하며, 더 이상 파이썬에서 고정 정밀도 정수형은 지원하지 않게 됐다.

bool은 엄밀히 따지면 논리 자료형인데 파이썬에서는 내부적으로 1(True)과 0(False)으로 처리되는 int의 서브 클래스다. int는 object의 하위 클래스이기도 하기 때문에 결국 다음과 같은 object > int > bool 구조를 띤다. 논리 자료형의 값인 True와 정수형의 값인 1을 비교해보면 `True == 1` True, `False == 0` True 이다.

비교 연산자 ==를 통해 확인한 결과 논리 자료형은 내부적으로 정수값을 갖고 있는 것을 확인할 수 있다.
