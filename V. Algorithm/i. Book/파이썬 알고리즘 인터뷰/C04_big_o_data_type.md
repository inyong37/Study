# 4장 빅오, 자료형
컴퓨터과학에서 빅오는 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 함께 공간 요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는 데 사용되며, 알고리즘의 효율성을 분석하는 데에도 매우 유용하게 활용된다.

## 빅오
빅오(O, big-O)란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법이다.

빅오는 점근적 실행 시간(Asymptotic Running Time)를 표기할 때 가장 널리 쓰이는 수학적 표기 중 하나다. 점근적 실행 시간이란 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 limit n-> inf 함수의 실행 시간의 추이를 의미한다. 알고리즘은 궁극적으로 컴퓨터로 구현되므로, 컴퓨터의 빠른 처리 능력을 감안하면 아무리 복잡한 알고리즘도 입력의 크기가 작으면 금방 끝나버린다. 그러므로 관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다. 충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.

점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있다. 시간 복잡도(Time Complexity)의 사전적 정의는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도(Computational Complexity)를 의미하며, 계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다.

- O(1): 입력값이 아무리 커도 실행 시간은 일정하다. 최고의 알고리즘이라 할 수 있다. O(1)에 실행되는 알고리즘으로 해시 테이블의 조회 및 삽입이 이에 해당한다.
- O(log n): 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편으로 웬만한 n의 크기에 대해서도 매우 견고하다. 대표적으로 이진 검색이 이에 해당한다.
- O(n): 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간(Linear-Time) 알고리즘이라고 한다. 정렬되지 않은 리스트에서 최댓값 또는 최솟값 경우가 이에 해당하며 이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴봐야 한다.
- O(n log n): 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다. 적어도 모든 수에 대해 한 번 이상은 비교해야 하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘도 O(n log n)보다 빠를 수 없다. 물론 입력값이 최선인 경우, 비교를 건너뛰어 O(n)이 될 수 있으며 팀소트(Timsort)가 이런 로직을 갖고 있다.
- O(n^2): 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당한다.
- O(2^n): 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다. n^2과 혼동하는 경우가 있는데 처음에는 비슷해 보이지만 2^n이 훨씬 더 크다.
- O(n!): 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제(Travelling Salesman Problem, TSP)를 브루트 포스로 풀이할 때가 이에 해당한다. 가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항 시간 내에는 계산이 어렵다.

빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰인다. 또한 알고리즘은 흔히 '시간과 공간이 트레이드오프(Space-Time Tradeoff)' 관계다. 이 말은 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다는 얘기다.

### 상한과 최악
빅오(O)는 상한(Upper Bound)을 의미한다. 이외에도 하한(Lower Bound)을 나타내는 빅오메가, 평균을 의미하는 빅세타가 있는데, 학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있다. 평균적인 시간보다는 상한 시간으로 단순화해서 주로 표현하는데, 매번 구분하는 것이 번거롭고 혼동되기도 하며 또한 상한으로만 표현하는 방법이 틀리지 않기 때문이기도 하다.

빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 '적당히 정확하게' 표현하는 방법일 뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이라는 점에 유의해야 한다.

빅오 표기는 복잡한 함수 f(n)이 있을 경우, 이 함수의 실행 상한과 하한을 의미한다. 즉 가장 빨리 실행될 때(하한), 가장 늦게 실행될 때(상한)를 뜻하며 이 중 가장 늦게 실행될 때를 빅오(O), 가장 빨리 실행될 때를 빅오메가, 평균적으로는 빅세타로 지칭한다.

빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.

### 분할 상환 분석
시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 분할 상환 분석 방법이 등장하는 계기가 됐다.

분할 상환 분석(Amortized Analysis)은 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나다. 분할 상환 분석이 유용한 대표적인 예로 '동적 배열'을 들 수 있는데, 동적 배열에서 더블링이 일어나는 일은 어쩌다 한 번뿐이지만, 이로 인해 '아이템 삽입 시간 복잡도는 O(n)이다.'라고 얘기하는 건 지나치게 비관적이고 정확하지도 않다. 따라서 이 경우 '분할 상환' 또는 '상각'이라고 표현하는, 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다. 이렇게 할 경우 동적 배열의 삽입 시 시간 복잡도는 O(1)이 된다. 이 방법은 1985년 미국의 수학자이자 컴퓨터과학자인 로버트 타잔(Robert Tarjan)이 "상각된 계산 복잡도(Amortized Computational Complexity)"라는 논문에서 처음으로 소개했으며, 그 유용함 덕북에 최근에는 시간 복잡도를 분석할 때 매우 보편적으로 널리 사용되는 방법이기도 하다.

### 병렬화
일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다. 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도 중 하나이다.

## 자료형
코딩 테스트에서도 가장 많이 사용할 2가지 자료형인 리스트(List)와 딕셔너리(Dictionary)에 대해 중점적으로 살펴본다.

### 파이썬 자료형
- 파이썬3 표준 타입 계층 구조
- None(class None Type)
- 숫자
  - 정수형
    - 정수(class int)
    - 불리언(class bool)
  - 실수(class float)
- 집합형
  - 집합(class set)
- 시퀀스
  - 불변
    - 문자열(class str)
    - 튜플(class tuple)
    - 바이트(class bytes)
  - 가변
    - 리스트(class list)
- 매핑
  - 딕셔너리(class dict)

#### 숫자
파이썬에서는 숫자 정수형으로 int만을 제공한다. int는 임의 정밀도를 지원하며, 더 이상 파이썬에서 고정 정밀도 정수형은 지원하지 않게 됐다.

bool은 엄밀히 따지면 논리 자료형인데 파이썬에서는 내부적으로 1(True)과 0(False)으로 처리되는 int의 서브 클래스다. int는 object의 하위 클래스이기도 하기 때문에 결국 다음과 같은 object > int > bool 구조를 띤다. 논리 자료형의 값인 True와 정수형의 값인 1을 비교해보면 `True == 1` True, `False == 0` True 이다.

비교 연산자 ==를 통해 확인한 결과 논리 자료형은 내부적으로 정수값을 갖고 있는 것을 확인할 수 있다.

:bulb: 임의 정밀도
임의 정밀도 정수형이란 무제한 자릿수를 제공하는 정수형을 말한다. 정수를 숫자의 배열로 간주한다. 즉 자릿수 단위로 쪼개어 배열 형태로 표현한다. 

예를 들어 123456789101112131415는 사이즈 3, 값 437976919, 87719511, 107로 표현할 수 있다. 이 표현을 다음 식으로 다시 변환이 가능하다.

`( 437976919 * 2^(30*0) ) + ( 87719511 * 2^(30*1) ) + ( 107*2^(30*2) ) = 123456789101112131415`

이처럼 자릿수 단위로 구분한 값을 별도로 계산하여 처리하게 된다. 임의 정밀도의 원리와 유사한 문제는 비트 조작에서 전가산기(Full Adder)를 응용한 문제를 풀이할 때 다룬다.

당연히 숫자를 임의 정밀도로 처리하면 계산 속도가 저하된다. 그러나 숫자를 단일형으로 처리할 수 있으므로 언어를 매우 단순한 구조로 만들 수 있을 뿐만 아니라, 언어를 사용하는 입장에서도 더 이상 오버플로를 고민할 필요가 없어 잘못된 계산 오류를 방지할 수 있다.

#### 매핑
매핑(Mapping) 타입은 키와 자료형으로 구성된 복합 자료형이며, 파이썬에 내장된 유일한 매핑 자료형은 바로 딕셔너리다.

#### 집합
파이썬의 집합 자료형인 set은 중복된 값을 갖지 않는 자료형이다. 집합은 딕셔너리와 동일하게 중괄호{}를 사용하므로 이 점에 유의해야 한다. 그러나 딕셔너리는 키(key)/값(Value) 형태이지만 집합은 값만 선언하므로 선언 형태를 보면 금방 타입을 판단할 수 있다. 동일한 방식으로 파이썬 컴파일러는 타입 결정을 자동으로 한다. set은 입력 순서가 유지되지 않으며, 중복된 값이 있을 경우 하나의 값만 유지한다.

#### 시퀀스
시퀀스(Sequence)는 우리말로 하면 수열 같은 의미로, 어떤 특정 대상의 순서 있는 나열을 뜻한다. 예를 들어 str은 문자의 순서 있는 나열로 문자열을 이루는 자료형이며, list는 다양한 값들을 배열 형태의 순서 있는 나열로 구성하는 자료형이다. 파이썬에서는 list라는 시퀀스 타입이 사실상 배열의 역할을 수행한다. 시퀀스는 불변(Imuutable)과 가변(Mutable)으로 구분하는데 말 그대로 불변은 값을 변경할 수 없다. 여기에는 str, tuple, bytes가 해당되는데, 한번 이 타입으로 선언되는 값은 변경할 수가 없다. str 타입의 변수는 참조하는 주소만 변경된다. 반면 list는 가변이다. 리스트는 자유롭게 값을 추가, 삭제할 수 있는 동적 배열이다. 

### 원시 타입
원시 타입(Primitive Type)은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워넣는다. 만약 배열이라면 물리 메모리(Physical Memory)에 자료형의 크기만큼 공간을 갖는 요소가 연속된 순서로 배치되는 형태가 된다. 원시 타입을 객체로 변환하면 여러 가지 작업을 수행할 수 있게 된다. 단순히 메모리에 숫자만 보관하고 있을 때는 하지 못했던 일들이 객체로 만들면 가능해지는 것이다. 대표적으로 문자로 변환한다든지, 16진수로 변환, 시프팅(Shifting) 같은 비트 조작도 지원한다. 다만 이를 위한 여러 가지 부가 정보가 추가되므로, 메모리 점유율이 늘어나고 당연히 계산 속도 또한 감소한다.

자바의 int 타입은 32비트인 데 반해 JOL(Java Object Layout) 실행 결과를 확인해보면 객체인 Integer는 128비트(16바이트)나 된다. 단순히 비교해봐도 4배의 공간을 더 차지한다. bool 원시 타입은 단 1비트에 불과하다. 그런데 객체인 Boolean은 무려 128비트나 차지한다. 128배나 더 공간을 차지하는 셈인데, 이처럼 객체는 편리하고 다양한 기능을 제공하기 위해 일정 부분 속도와 공간을 희생하게 된다.

C나 자바는 성능에 대한 우선순위가 높은 언어다. 때문에 좀 더 하드웨어에 가까운 원시 타입을 별도로 제공하며, 원시 타입으로 구현했을 때 훨씬 더 빠른 속도로 실행할 수 있다. 파이썬은 원시 타입을 지원하지 않는다. 파이썬은 애초에 애초에 편리한 기능 제공에 우선순위를 둔 언어인 만큼 느린 속도와 더 많은 메모리를 차지하더라도 훨씬 더 다양한 기능을 제공할 수 있는 객체에 관심을 두는 게 어찌 보면 당연하다. 파이썬은 원시 타입의 속도를 포기하는 대신 객체의 다양한 기능과 편의성을 택했다.

- C: 원시 타입
- Java: 원시 타입, 객체
- Python: 객체
