# 7장 배열
데이터 요소가 순차적(Sequential)으로 배열되는 자료구조를 선형(Linear) 자료구조라고 한다. 선형 자료구조는 단일 레벨로 구성된다. 따라서 한 번에 탐색이 가능하며, 구현하기도 쉽다.

배열은 값 또는 변수 엘리먼트의 집합으로 구성된 구조로, 하나 이상의 인덱스 또는 키로 식별된다.

자료구조는 크게 메모리 공간 기반의 연속(Contiguous) 방식과 포인터 기반의 연결(Link) 방식으로 나뉜다. 배열은 이 중에서 연속 방식의 가장 기본이 되는 자료형이다. 

:bulb: 메모리와 포인터

32비트 머신의 포인터는 32비트며, 64비트 머신의 포인터는 64비트다. 포인터(Pointer)는 메모리 영역을 1바이트 단위로 가리키는 주소인데, 과거 32비트 머신은 메모리 주소를 0에서 2^32-1까지 밖에 표현할 수 없었고, 최대 약 4GB까지만 지정할 수 있었다. 따라서 메모리를 4GB 이상 인식할 수 없는 문제가 있었는데, 최근에 64비트 시스템들은 2^64, 약 16EB(엑사바이트)라는 엄청난 크기의 가상 메모리를 가리킬 수 있어 이 정도면 한동안은 충분하다고 볼 수 있다. 물론 과거 빌 게이츠가 640KB면 충분하다고 말했다가 한동안 망신을 당했던 것처럼 이 또한 언젠가는 늘려야할 날이 반드시 찾아올 것이다.

크기를 지정하지 않고 자동으로 리사이징하는 배열인 동적 배열이 등장했다. 자바에서는 ArrayList, C++에서는 std::vector기 대표적인 동적 배열 자료형이다. 파이썬에서는 리스트가 바로 동적 배열 자료형이다. 대부분의 동적 프로그래밍 언어(Dynamic Programming Language)들은 아예 정적 배열 자체가 없다. 파이썬에서도 정적 배열은 따로 제공하지 않으며 동적 배열인 리스트만 제공한다. 재할당 비율을 그로스 팩터(Growth Factor), 즉 성장 인자라고 한다. 파이썬의 그로스 팩터는 초반에는 2배씩 늘려가지만, 전체적으로는 약 1.125배로, 다른 언어에 비해서는 다소 조금만 늘려가는 형태로 구현되어 있다. 참고로 자바의 ArrayList는 1.5배, C++의 std::vector나 루비 같은 언어는 2배씩, 말 그대로 더블링으로 과감하게 늘려나간다. 더블링이 필요할 만큼 공간이 차게 되면, 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요하므로 O(n) 비영이 발생한다. 즉 최악의 경우 삽입 시 O(n)이 되지만 자주 일어나는 일은 아니므로 분할 상환 분석에 따른 입력 시간(Amortized Insertion Time)은 여전히 O(1)이다.

자동으로 리사이징하는 배열인 동적 배열이 있다. 대부분의 프로그래밍 언어는 동적 배열을 지원하며, 자바에서는 ArrayList, C++에서는 std::vector가 대표적인 동적 배열 자료형이다. 파이썬에서는 리스트가 바로 동적 배열 자료형이다. 대부분의 동적 프로그래밍 언어(Dynamic Programming Language)들은 아예 정적 배열 자체가 없다. 파이썬에서도 정적 배열은 따로 제공하지 않으며 동적 배열인 리스트만 제공한다. 동적 배열의 원리는 간단하다. 미리 초깃값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면, 늘려주고 모두 복사한느 식이다. 대개는 더블링(Doubling)이라 하여 2배씩 늘려주게 되는데, 당연히 모든 언어가 항상 그런 것은 아니며 각 언어마다 늘려가는 비율은 상이하다. CPython의 리스트 구현은 CPython의 listobject.c에 정의되어 있다. 여기에는 다음 코드에서 주석에 기술된 수치만큼인 0, 4, 8, 16, ... 순으로 재할당하도록 정의되어 있다.

```Python
// cpython/Objects/listobject.c
// The growth pattern is: 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
new_allocated = (size_t)newsize + (newsize >> 3) + (newsize < 9 ? 3 : 6);
```

이 재할당 비율을 그로스 팩터(Growth Factor), 즉 '성장 인자'라고 한다. 파이썬의 그로스 팩터는 초반에는 2배씩 늘려 가지만, 전체적으로는 약 1.125배로, 다른 언어에 비해서는 다소 조금씩만 늘려가는 형태로 구현되어 있다. 참고로 자바의 ArrayList는 1.5배, C++의 std::vector나 루비 같은 언어는 2배씩, 말 그대로 더블링으로 과감하게 늘려나간다. 크기가 용량만큼 차제 되면, 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요하므로 O(n)의 비용이 발생한다. 즉 최악의 경우 삽입 시 O(n)이 되지만 자주 일어나는 일이 아니므로, 분할 상환 분석에 따른 입력 시간(Amortuzed Insertion Time)은 여전히 O(1)이다. 이처럼 동적 배열은 분할 상환 분석에 따른 시간 복잡도를 설명하는 대표적인 자료형이기도 하다.

