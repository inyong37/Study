# 1장 오프젝트와 의존관계

스프링은 자바를 기반으로 한 기술이다. 스프링이 자바에서 가장 중요하게 가치를 두는 것은 바로 객체지향 프로그래밍이 가능한 언어라는 점이다.

스프링이 가장 관심을 많이 두는 대상은 오브젝트다.

## 1.1 초난감 DAO

:bulb: DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

:bulb: 자바빈(JavaBean)은 원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다. 자바의 주력 개발 플랫폼이 웹 기반의 엔터프라이즈 방식으로 바뀌면서 비주얼 컴포넌트로서 자바빈을 인기를 잃어갔지만, 자바빈의 몇 가지 코딩 관례는 JSP 빈, EJB와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져 왔다. 이제는 자자빈이라고 말하면 비주얼 컴포넌트라기보다는 다음 두 가지 관례를 따라 만들어진 오브젝트를 가리킨다. 간단히 빈이라고 부르기도 한다.

* 디폴트 생성자: 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
* 프로퍼티: 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

## 1.2 DAO의 분리

## 1.3 DAO의 확장

## 1.4 제어의 역전(IoC, Inversion of Control)

### 1.4.1 오브젝트 팩토리

### 팩토리 Factory

* 이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려줌
  * 디자인 패턴에서 말하는 특별한 문제를 해결하기 위해 사용되는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다름
* 단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용함
* 어떻게 만들지와 어떻게 사용할지는 다름

```Java
package springbook.user.dao;
...
public class DaoFactory {
  public UserDao userDao() {
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao userDao = new UserDao(connectionMaker);
    return userDao;
  }
}
```

* DaoFactory의 userDao 메소드를 호출하면 DConnectionMaker를 사용해 DB 커넥션을 가져오도록 이미 설정된 UserDao 오브젝트를 돌려줌
* UserDaoTest는 이제 UserDao가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경 쓰지 않고 팩토리로부터 UserDao 오브젝트를 받아다가, 자신의 관심사인 테스트를 위해 활용하기만 하면 됨

```Java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    UserDao dao = new DaoFactory().userDao();
    ...
  }
}
```

리팩토링한 뒤에는 잊지 말고 테스트를 실행하자.

### 설계도로서의 팩토리

* UserDao와 ConnetionMaker는 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있음
* DaoFactory는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있음
  * 전자가 실질적인 로직을 담당하는 컴포넌트라면, 후자는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할임

* 이제 N사와 D사에 UserDao를 공급할 때 UserDao, ConnectionMaker와 함께 DaoFactory도 제공함
  * UserDao와 달리 DaoFactory는 소스를 제공함
  * 새로운 ConnectionMaker 구현 클래스로 변경이 필요하면 DaoFactory를 수정해서 변경된 클래스를 생성해 설정해주도록 코드를 수정하면 됨
  * DB 연결 방식은 자유로운 확장이 가능함

* 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있음

### 1.4.2 오브젝트 팩토리의 활용

* 여러 개의 DAO를 생성하는 메소드가 추가된 리스트
   오브젝트 생성 코드가 중복되는 건 좋지 않은 현상임

```Java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(new DConnectionMaker());
  }

  public AccountDao accountDao() {
    return new AccountDao(new DConnectionMaker());
  }

  public MessageDao messageDao() {
    return new MessageDao(new DConnectionMaker());
  } 
}
```

* 중복 문제를 해결하려면 역시 분리해내는 게 가장 좋은 방법임
* ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 코드를 별도의 메소드로 분리함.

```Java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  public AccountDao accountDao() {
    return new AccountDao(connectionMaker());
  }

  public MessageDao messageDao() {
    return new MessageDao(connectionMaker());
  }

  public ConnectionMaker connectionMaker() {
    return new DConnectionMaker();
  }
}
```

### 1.4.3 제어권의 이전을 통한 제어관계 역전

* 프로그램의 제어 흐름 구조가 뒤바뀌는 것
* 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택/생성하지 않음
  * 모든 제어 권한을 자신이 아닌 다른 대상에게 위임함
  * 프로그램의 시작을 담당하는 main()과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어짐
* 서블릿을 개발해 서버에 배포할 수는 있지만, 그 실행을 개발자가 직접 제어할 수 있는 방법은 없음
  * 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출함
* 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 함
  * 템플릿 메소드는 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이라 볼 수 있음
* 프레임워크도 제어의 역전 개념이 적용된 대표적인 기술임
  * 프레임워크는 단지 미리 만들어둔 반제품이나, 확장해서 사용할 수 있도록 준비된 추상 라이브러리의 집합이 아님
  * 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어함
  * 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐임
  * 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용됨
  * 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식임
* 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요함
  * DaoFactory는 오브젝트 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있음

## 1.5 스프링의 IoC

* 빈 팩토리
* 애플리케이션 컨텍스트

### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

### 애플리케이션 컨텍스트와 설정정보

* 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 부름
  * 자비빈 또는 엔터프라이즈 자바빈(EJB)에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트를 말함
  * 동시에 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가르킴
* 스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory)라고 부름
  * 보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트(application context)를 주로 사용함
  * 이는 IoC 방식을 따라 만들어진 일종의 빈 팩토리임
  * 빈 팩토리라고 말할 때는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점
  * 애플리케이션 컨텍스트라 말할 때는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 좀 더 부각됨
*  애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈(오브젝트)의 생성, 관계설정 등의 제어 작업을 총괄함

### DaoFactory를 사용하는 애플리케이션 컨텍스트

* 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 @Configuration이라는 애노테이션을 추가함
* 오브젝트를 만들어 주는 메소드에는 @Bean이라는 애노테이션을 붙여줌
  * userDao() 메소드는 UserDao 타입 오브젝트를 생성하고 초기화해서 돌려주는 것이니 @Bean이 붙음
  * ConnectionMaker 타입의 오브젝트를 생성해주는 connectionMaker() 메소드에도 @Bean을 붙임

```Java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
...
@Configuration
public class DaoFactory {
  @Bean
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  @Bean
  public ConnectionMaker connectionMaker() {
    return new DConnectionMaker();
  }
}
```

* DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트:
  * ApplicationContext 타입의 오브젝트
  * AnnotationConfigApplicationContext를 이용하면 됨
 
```Java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao", UserDao.class);
  }
}
```

* getBean() 메소드는 ApplicationContext가 관리하는 오브젝트를 요청하는 메소드임
* getBean()의 파라미티어니 userDao는 ApplicationContext에 등록된 빈의 이름임
* DaoFactory에서 @Bean이라는 애노테이션을 userDao라는 이름의 메소드에 붙였는데, 이 메소드 이름이 바로 빈의 이름이 됨
* userDao라는 이름의 빈을 가져온다는 것은 DaoFactory의 userDao() 메소드를 호출해서 그 결과를 가져옴
  * 메소드의 이름을 myPreciousUserDao()라고 했다면 getBean("myPrecisionUserDao" UserDao.class)로 가져올 수 있음

* getBean()은 기본적으로 Ojbect 타입으로 리턴하게 되어 있어서 매번 리넡되는 오브젝트에 다시 캐스팅을 해줘야 하는 부담이 있음
  * Java 5 이상의 generic 메소드 방식을 이용해 getBean()의 두 번째 파라미터에 리턴 타입을 주면, 지저분한 캐스팅 코드를 사용하지 않아도 됨

### 1.5.2 애플리케이션 컨텍스트의 동작방식

오브젝트 팩토리 vs 스프링의 애플리케이션 컨텍스트

* 애플리케이션 컨텍스트 = IoC 컨테이너 = 스프링 컨테이너 = 빈 팩토리
  * 애플리케이션 컨텍스트는 AppilicationContext 인터페이스를 구현하는데, ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션은 일종의 빈 팩토리임

* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

### 1.5.3 스프링 IoC의 용어 정리

* 빈 (bean)

* 빈 팩토리 (bean factory)

* 애플리케이션 컨텍스트 (application context)

* 설정정보/설정 메타정보 (configuration metadata)

* 컨테이너 (container) 또는 IoC 컨테이너

* 스프링 프레임워크

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

:bulb: 오브젝트의 동일성(identical)과 동등성(equivalent): 동일성은 == 연산자로, 동등성은 equals() 메소드를 이용해 비교한다. 두 개의 오브젝트가 동일하다면 사실은 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다. 두 개의 오브젝트가 동일하지는 않지만 동등한 경우에는 두 개의 각기 다른 오브젝트가 메모리상에 존재하는 것인데, 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다. 자바 클래스를 만들 때 euqals() 메소드를 따로 구현하지 않았다면, 최상위 클래스인 Object 클래스에 구현되어 있는 equals() 메소드가 사용된다. Object의 equals() 메소드는 두 오브젝트의 동일성을 비교해서 그 결과를 돌려준다. 동일한 오브젝트여야지만 동등한 오브젝트이다.

* 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려줌

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

* 애플리케이션 컨텍스트는 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너임
* 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리(singleton registry)이기도 함
* 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만듦
* 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 구현 방법은 다름

### 서버 애플리케이션과 싱글톤

* 왜 스프링은 싱글톤으로 빈을 만드는 것일까?
  * 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문임
  * 아무리 자바의 오브젝트 생성과 가비지 컬렉션(GC)의 성능이 좋아졌다고 한들 새로운 오브젝트 부하가 걸리면 감당하기 힘듦
* 서비스 오브젝트 "서블릿"
  * 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작함
  * 서블릿 클래스당 하나의 오브젝트만 만들어둠
  * 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용함
 
:bulb: 싱글톤 패턴(Singleton Pattern): 싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하다. 단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.

### 싱글톤 패턴의 한계

자바에서 싱글톤을 구현하는 방법:

* 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
* 생성된 싱글톤 어브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
* 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
* 한번 오브젝트(싱글톤)가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

```Java
public class UserDao {
  private static UserDao INSTANCE;
  ...
  private UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }
  
  public static synchronized UserDao getInstance() {
    if (INSTANCE == null) INSTANCE = new UserDao(???);
    return INSTANCE;
  }
  ...
}
```

* private 생성자를 갖고 있기 때문에 상속할 수 없다
* 싱글톤은 테스트하기가 힘들다
* 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
* 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다

### 싱글톤 레지스트리

* 스프링은 자바의 기본적인 싱글톤 패턴의 구현 방식이 아닌 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공함
* 싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해줌

### 1.6.2 싱글톤과 오브젝트의 상태

* 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 함
  * 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험함
  * 저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문임
  * 싱글톤은 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful) 방식으로 만들지 않음
  * 읽기전용의 값이라면 초기화 시점에서 인스턴스 변수에 저장해두고 공유하는 것은 괜찮음
  * 파라미터, 로컬 변수, 리턴 값 등을 이용하면 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 여러 스레드가 변수의 값을 덮어쓸 일은 없음
  * 동일하게 읽기전용의 속성을 가진 정보라면 싱글톤에서 인스턴스 변수로 사용해도 좋음
  * 단순한 읽기전용 값이라면 static final이나 final로 선언하는 편이 나음
 
### 1.6.1 스프링 빈의 스코프

* 스프링 빈의 기본 스코프는 싱글톤임
  * 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지됨
  * 스프링에서 만드는 대부분의 빈은 싱글톤 스코프를 갖음
 * 프로토타입 스코프는 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어줌
 * 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성되는 요청(request) 스코프
 * 웹의 세션과 스코프가 유사한 세션(session) 스코프

## 1.7 의존관계 주입(DI)

### 1.7.1 제어의 역전(IoC)과 의존관계 주입

* 스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입(Dependency Injection)이라고 불림

:bulb: 의존관계 주입, 의존성 주입, 의존 오브젝트 주입?: 오브젝트의 레퍼런스가 전달될 뿐이다. DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다. 

### 1.7.2 런타임 의존관계 설정

### 의존관계

* 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 함

```
|-|     |-|
|A| - > |B|
|-|     |-|
```
* 의존한다는 건 의존대상, 여기서는 B가 변하면 그것이 A에 영향을 미친다는 뜻임
  * B의 기능이 추가되거나 변경되거나, 형식이 바뀌거나 하면 그 영향이 A로 전달된다는 것임

### UserDao의 의존관계

* 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 됨
  *  결합도가 낮음
  *  의존관계란 한쪽의 변화가 다른 쪽에 영향을 주는 것
  *  인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워짐

* 런타임 시에 오브젝트 사이에 만들어지는 의존관계
  * 런타임 의존관계 또는 오브젝트 의존관계, 설계 시점의 의존관계가 실체화된 것
  * 모델링 시점의 의존관계와는 성격이 다름
  * 실제 사용대상인 오브젝트를 의존 오브젝트(dependent object)라 함
 
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.



## 1.8 XML을 이용한 설정

## 1.9 정리

1장에선 사용자 정보를 DB에 등록하거나 아이디로 조회하는 기능을 가진 간단한 DAO 코드를 만들고, 그 코드의 문제점을 살펴본 뒤, 이를 다양한 방법과 패턴, 원칙, IoC/DI 프레임워크까지 적용해서 개선해왔다.

* 책임이 다른 코드를 분리해서 두 개의 클래스로 만들었다(관심사의 분리, 리팩토링).
* 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고, 다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다. 이렇게 해서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도, 그 기능을 사용하는 클래스의 코드는 같이 수정할 필요가 없도록 만들었다(전력 패턴).
* 
