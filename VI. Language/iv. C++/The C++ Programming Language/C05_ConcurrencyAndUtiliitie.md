# 5 C++ 둘러보기: 병행성과 유틸리티

## 5.2 자원 관리
오래 실행되는 프로그램의 경우 적절한 시점에 자원을 해제하지 못하면('누출') 심각한 성능 저하의 원인이 될 수 있으며, ㅣ참하게 프로그램이 멈출 수도 있다. 짧은 프로그램인 경우에도 누출은 골칫거리가 될 수 있는데, 자원 부족으로 인해 실행 시간이 몇 배 늘어날 수 있기 때문이다.

생성자/소멸자 쌍은 자원이 그것을 담당하는 객체보다 오래 살아남지 않게 보장해준다.

### 5.2.1 unique_ptr과 shared_ptr
지금까지의 예제들은 유효 범위 내에서 정의돼 유효 범위를 빠져 나갈 때 획득한 자원을 하제하는 객체를 다뤄왔다. 그렇다면 자유 저장 공간에 할당된 객체들은 어떻게 해야 하는가? <memory>에서 표준 라이브러리는 자유 공간에 있는 객체를 관리하는 데 도움을 주는 두 가지의 '스마트 포인터'를 제공한다.

1. 고유 소유권을 표시하는 unique_ptr (34.3.1절)
2. 공유 소유권을 표시하는 shared_ptr (34.3.2절)

이러한 '스마트 포인터'의 가장 기본적인 용도는 부주의한 프로그래밍에 의해 일어날 수 있는 메모리 누출을 방지하는 것이다. 예를 들면 다음과 같다.
```C++
void f(int t, int j) // X*와 unique_ptr<X>의 비교
{
    X* p =new X; // 새로운 X를 할당한다.
    unique_ptr<X> sp {new X}; // 새로운 X를 할당하고 그것의 포인터를 unique_ptr에 넣는다.
    // ...
    
    if (i<99) throw Z{}; // 예외를 던질 수 있다.
    if (j<77) return; // "일찍" 반환할 수 있다.
    p->do_something(); // 예외를 던질 수 있다.
    sp->do_something(); // 예외를 던질 수 있다.
    // ...
    delete p; // *p를 소멸시킨다.
}
```
여기서 i<99이거나 i<77인 경우 p를 소멸시키는 것을 잊어 먹었다. 반면 unique_ptr은 어떤 방식으로 f()를 빠져 나가든 그것의 객체가 소멸되게 보장해준다(예외를 던지거나, return을 반환하거나 아니면 '끝에서 떨어져 나감으로써'). 역설적이겠지만 포인터를 쓰지 않거나 new를 사용하지만 않았어도 이런 문제가 해결됐을 것이다.
```C++
void f(int i, int j) // 지역 변수를 사용한다.
{
    X x;
    // ...
}
```
안타깝게도 new(그리고 포인터와 참조자)를 많이 사용할수록 문제가 점점 늘어나는 것으로 보인다. 하지만 포인터의 의미 구조가 정말로 필요할 때 unique_ptr은 기본 제공 포인터를 사용하는 표준적인 방식에 비해 공간이나 시간 오버헤드가 없는 상당히 가벼운 메커니즘이다. 이것의 또 다른 용도는 자유 저장 공간에 할당된 객체를 함수 안팎으로 전달하는 것이다.
```C++
unique_ptr<X> make_X(int i) // X를 만들고 곧바로 unique_ptr을 할당한다.
{
    // ... i의 검사 등 ...
    return unique_ptr<X>{new X{i}};
}
```
vector가 객체의 시퀀스에 대한 핸들인 것과 마찬가지로 unique_ptr은 객체(또는 배열)에 대한 핸들이다. 둘 다 다른 객체의 수명을 제어하며(RAII를 이용해서), 둘 다 return 을 간단하고 효율적으로 만들기 위해 이동 의미 구조에 의존한다.

shared_ptr은 이동되지 않고 복사된다는 점만 제외하면 unique_ptr과 비슷하다. 어떤 객체에 대한 shared_ptr들은 해당 객체의 소유권을 공유하며, 해당 객체는 그것의 마지막 shared_ptr이 소멸될 때 소멸된다. 예를 들면 다음과 같다.
```C++
void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);
void user(const string& name, ios_base::openmode mode)
{
    shared_ptr<fstream> fp {new fstream(name, mode)};
    if (!*fp) throw No_file{}; // 파일이 제대로 열려 있는지 확인한다.
    f(fp);
    g(fp);
    // ...
``` 
이제 fp의 생성자에 의해 열린 파일은 fp의 사본을 (명시적 또는 암시적으로) 소멸시키는 마지막 함수에 의해 닫힐 것이다. f()나 g()는 fp의 사본을 보관하는 태스크를 생성하거나 뭔가 다른 방식으로 user()보다 오래 살아남는 사본을 저장하지 않는다는 점에 유의한다. 따라서 shared_ptr은 메모리 관리 객체를 소멸자 기반으로 자원 관리하는 방식으로 일종의 가비지 컬렉션을 제공하는 셈이다. 이런 방식은 아무런 비용이 들지도 않고 터무니없는 비용이 드는 것도 아니지만, 공유 객체의 수명을 예측하기 어렵게 만드는 것은 사실이다. shared_ptr은 실제로 공유 소유권이 필요한 경우에만 사용돼야 한다.

unique_ptr과 shared_ptr이 있으면 많은 프로그램에 대해 '무방비의 new가 없는' 정책을 실현할 수 있다. 하지만 이런 '스마트 포인터'는 개념적으로는 여전히 포인터이기 때문에 자원 관리에 있어 차선책에 불과하다. 좀 더 높은 개념적 수준으로 자원을 관리하는 컨테이너를 비롯한 다른 탕비이 더 우선인 것ㅇ이다. 특히 shared_ptr은 그들의 소유자가 공유 객체를 읽거나 공유 객체에 기록하기 위해 필요한 아무런 규칙도 자체적으로 제공하지 못한다. 데이터 경합(41.2.4)과 다른 형태의 혼란은 그저 자원 관리 이슈만 제거한다고 해서 해결되지는 않는다.

그렇다면 자원 전용으로 설계된 연산을 가진 자원 핸들(vector나 thread 등)보다 '스마트 포인터(unique_ptr 등)'는 어느 경우에 사용해야 하는가? 당연하겠지만 그 답은 '포인터 의미 구조가 필요할 때'다.

- 어떤 객체를 공유할 때는 공유 객체를 참조하기 위해 포인터(또는 참조자)가 필요하므로, shared_ptr이 확실한 선택이 된다(명확한 단일 소유자가 있지 않는 한).
- 다형성 객체를 참조할 때는 참조되는 객체의 정확한 타입을 알지 못하는 관계로 포인터(또는 참조자)가 필요하므로, unique_ptr이 확실한 선택이 된다.
- 공유 다형성 객체는 대개 shared_ptr을 필요로 한다.

함수에서 객체의 집합을 변환하기 위해 포인터를 사용할 필요는 없다. 자원 핸들인 컨테이너가 그 역할을 간단하고 효율적으로 수행할 것이다(3.3.2).

### 5.3.1 태스크와 스레드
다른 계산과 병행해서 수행될 수 있는 계산은 태스크(task)라고 불린다. 스레드(thread)는 프로그램에 들어 있는 태스크를 시스템 수준으로 표현한 것이다. 다른 태스크와 병행 수행될 수 있는 태스크는 태스크를 인자로 넣어서 std::tread(Mthread>에 있는)를 생성함으로써 시작될 수 있다. 태스크는 함수 아니면 함수 객체다.
```C++
void f(); // 함수
struct F { // 함수 객체
    void operator() (); // F의 호출 연산자(3.4.3)
};

void user()
{
    thread t1 {f}; // f()는 별도의 스레드에서 실행된다.
    thread t2 {F()}; // F() ()는 별도의 스레드에서 실행된다.
    t1.join(); // t1을 기다린다.
    t2.join(); // t2를 기다린다.
}
``` 
join()은 스레드가 완료되기 전까지 user()를 빠져 나가지 못하게 보장한다. 'join'이란 "스레드가 종료될 때까지 기다린다"는 의미다.

한 프로그램의 스레드는 단일 주소 공간을 공유한다. 이런 측면에서 스레드는 일반적으로 데이터를 직접적으로 공유하지 않는 프로세스와는 다르다. 스레드는 주소 공간을 공유하므로, 공유 객체(5.3.4)를 통해 서로 통신할 수 있다. 보통 그러한 통신은 데이터 경합(변수에 대한 제어되지 않은 동시적인 접근)을 방지해 주는 잠금이나 여타 메커니즘에 의해 제어된다.

병행 태스크를 프로그래밍하는 일은 상당히 까다로울 수 있다. 태스크 f(어떤 함수)와 태스크 F(어떤 함수 객체)로 가능한 구현을 살펴보자.
```C++
void f() { cout << "Hello "; }
struct F {
    void operator() () { cout << "Parelle World!\n"; }
};
```
이 코드는 나쁜 오류가 일어나는 예다. 여기서 f와 F()는 아무런 형태의 동기화 없이 cout 객체를 제각기 사용한다. 두 태스크에서 개별 연산의 처리 순서가 정의되어 있지 않기 때문에 결과 출력은 예측 불가하고, 프로그램의 실행 상황에 따라 가변적일 것이다. 이 프로그램은 다음과 같은 '이상한' 결과를 내놓을 것이다.
```bash
PaHerallllel o World!
```
병행성 프로그램의 태스크를 정의할 때는 간단하고 명확한 방식으로 서로 통신해야 하는 경우를 제외하고는 태스크를 완전히 분리하는 것을 목표로 해야 한다. 병행 태스크를 이해하는 가장 간단한 방식은 호출자와 동시에 실행되는 함수로 생각하는 것이다. 이런 함수가 동작하기 위해서는 인자를 전달하고, 결과를 되돌려 받아야 하며, 소라 간에 공유되는 데이터가 존재하지 않게 해야 한다(데이터 경합이 발생하지 않게).
  